// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.4.0
// - protoc             v5.27.1
// source: internal/proto/speech.proto

package proto

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	emptypb "google.golang.org/protobuf/types/known/emptypb"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.62.0 or later.
const _ = grpc.SupportPackageIsVersion8

const (
	UserAccountService_CreateUser_FullMethodName         = "/auth.UserAccountService/CreateUser"
	UserAccountService_GetUserById_FullMethodName        = "/auth.UserAccountService/GetUserById"
	UserAccountService_GetUsersByUsername_FullMethodName = "/auth.UserAccountService/GetUsersByUsername"
	UserAccountService_UpdateUser_FullMethodName         = "/auth.UserAccountService/UpdateUser"
	UserAccountService_DeleteUser_FullMethodName         = "/auth.UserAccountService/DeleteUser"
)

// UserAccountServiceClient is the client API for UserAccountService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// User Account Service
type UserAccountServiceClient interface {
	CreateUser(ctx context.Context, in *CreateUserRequest, opts ...grpc.CallOption) (*CreateUserResponse, error)
	GetUserById(ctx context.Context, in *GetUserByIdRequest, opts ...grpc.CallOption) (*User, error)
	GetUsersByUsername(ctx context.Context, in *GetUsersByUsernameRequest, opts ...grpc.CallOption) (*GetUsersByUsernameResponse, error)
	UpdateUser(ctx context.Context, in *UpdateUserRequest, opts ...grpc.CallOption) (*User, error)
	DeleteUser(ctx context.Context, in *DeleteUserRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type userAccountServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewUserAccountServiceClient(cc grpc.ClientConnInterface) UserAccountServiceClient {
	return &userAccountServiceClient{cc}
}

func (c *userAccountServiceClient) CreateUser(ctx context.Context, in *CreateUserRequest, opts ...grpc.CallOption) (*CreateUserResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CreateUserResponse)
	err := c.cc.Invoke(ctx, UserAccountService_CreateUser_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userAccountServiceClient) GetUserById(ctx context.Context, in *GetUserByIdRequest, opts ...grpc.CallOption) (*User, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(User)
	err := c.cc.Invoke(ctx, UserAccountService_GetUserById_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userAccountServiceClient) GetUsersByUsername(ctx context.Context, in *GetUsersByUsernameRequest, opts ...grpc.CallOption) (*GetUsersByUsernameResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetUsersByUsernameResponse)
	err := c.cc.Invoke(ctx, UserAccountService_GetUsersByUsername_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userAccountServiceClient) UpdateUser(ctx context.Context, in *UpdateUserRequest, opts ...grpc.CallOption) (*User, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(User)
	err := c.cc.Invoke(ctx, UserAccountService_UpdateUser_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userAccountServiceClient) DeleteUser(ctx context.Context, in *DeleteUserRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, UserAccountService_DeleteUser_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// UserAccountServiceServer is the server API for UserAccountService service.
// All implementations must embed UnimplementedUserAccountServiceServer
// for forward compatibility
//
// User Account Service
type UserAccountServiceServer interface {
	CreateUser(context.Context, *CreateUserRequest) (*CreateUserResponse, error)
	GetUserById(context.Context, *GetUserByIdRequest) (*User, error)
	GetUsersByUsername(context.Context, *GetUsersByUsernameRequest) (*GetUsersByUsernameResponse, error)
	UpdateUser(context.Context, *UpdateUserRequest) (*User, error)
	DeleteUser(context.Context, *DeleteUserRequest) (*emptypb.Empty, error)
	mustEmbedUnimplementedUserAccountServiceServer()
}

// UnimplementedUserAccountServiceServer must be embedded to have forward compatible implementations.
type UnimplementedUserAccountServiceServer struct {
}

func (UnimplementedUserAccountServiceServer) CreateUser(context.Context, *CreateUserRequest) (*CreateUserResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateUser not implemented")
}
func (UnimplementedUserAccountServiceServer) GetUserById(context.Context, *GetUserByIdRequest) (*User, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetUserById not implemented")
}
func (UnimplementedUserAccountServiceServer) GetUsersByUsername(context.Context, *GetUsersByUsernameRequest) (*GetUsersByUsernameResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetUsersByUsername not implemented")
}
func (UnimplementedUserAccountServiceServer) UpdateUser(context.Context, *UpdateUserRequest) (*User, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateUser not implemented")
}
func (UnimplementedUserAccountServiceServer) DeleteUser(context.Context, *DeleteUserRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteUser not implemented")
}
func (UnimplementedUserAccountServiceServer) mustEmbedUnimplementedUserAccountServiceServer() {}

// UnsafeUserAccountServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to UserAccountServiceServer will
// result in compilation errors.
type UnsafeUserAccountServiceServer interface {
	mustEmbedUnimplementedUserAccountServiceServer()
}

func RegisterUserAccountServiceServer(s grpc.ServiceRegistrar, srv UserAccountServiceServer) {
	s.RegisterService(&UserAccountService_ServiceDesc, srv)
}

func _UserAccountService_CreateUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateUserRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserAccountServiceServer).CreateUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserAccountService_CreateUser_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserAccountServiceServer).CreateUser(ctx, req.(*CreateUserRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserAccountService_GetUserById_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetUserByIdRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserAccountServiceServer).GetUserById(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserAccountService_GetUserById_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserAccountServiceServer).GetUserById(ctx, req.(*GetUserByIdRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserAccountService_GetUsersByUsername_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetUsersByUsernameRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserAccountServiceServer).GetUsersByUsername(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserAccountService_GetUsersByUsername_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserAccountServiceServer).GetUsersByUsername(ctx, req.(*GetUsersByUsernameRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserAccountService_UpdateUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateUserRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserAccountServiceServer).UpdateUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserAccountService_UpdateUser_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserAccountServiceServer).UpdateUser(ctx, req.(*UpdateUserRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserAccountService_DeleteUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteUserRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserAccountServiceServer).DeleteUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserAccountService_DeleteUser_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserAccountServiceServer).DeleteUser(ctx, req.(*DeleteUserRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// UserAccountService_ServiceDesc is the grpc.ServiceDesc for UserAccountService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var UserAccountService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "auth.UserAccountService",
	HandlerType: (*UserAccountServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateUser",
			Handler:    _UserAccountService_CreateUser_Handler,
		},
		{
			MethodName: "GetUserById",
			Handler:    _UserAccountService_GetUserById_Handler,
		},
		{
			MethodName: "GetUsersByUsername",
			Handler:    _UserAccountService_GetUsersByUsername_Handler,
		},
		{
			MethodName: "UpdateUser",
			Handler:    _UserAccountService_UpdateUser_Handler,
		},
		{
			MethodName: "DeleteUser",
			Handler:    _UserAccountService_DeleteUser_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "internal/proto/speech.proto",
}

const (
	AuthenticationService_Login_FullMethodName        = "/auth.AuthenticationService/Login"
	AuthenticationService_Logout_FullMethodName       = "/auth.AuthenticationService/Logout"
	AuthenticationService_RefreshToken_FullMethodName = "/auth.AuthenticationService/RefreshToken"
)

// AuthenticationServiceClient is the client API for AuthenticationService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// Authentication Service
type AuthenticationServiceClient interface {
	Login(ctx context.Context, in *LoginRequest, opts ...grpc.CallOption) (*LoginResponse, error)
	Logout(ctx context.Context, in *LogoutRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	RefreshToken(ctx context.Context, in *RefreshTokenRequest, opts ...grpc.CallOption) (*RefreshTokenResponse, error)
}

type authenticationServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewAuthenticationServiceClient(cc grpc.ClientConnInterface) AuthenticationServiceClient {
	return &authenticationServiceClient{cc}
}

func (c *authenticationServiceClient) Login(ctx context.Context, in *LoginRequest, opts ...grpc.CallOption) (*LoginResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(LoginResponse)
	err := c.cc.Invoke(ctx, AuthenticationService_Login_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authenticationServiceClient) Logout(ctx context.Context, in *LogoutRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, AuthenticationService_Logout_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authenticationServiceClient) RefreshToken(ctx context.Context, in *RefreshTokenRequest, opts ...grpc.CallOption) (*RefreshTokenResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RefreshTokenResponse)
	err := c.cc.Invoke(ctx, AuthenticationService_RefreshToken_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// AuthenticationServiceServer is the server API for AuthenticationService service.
// All implementations must embed UnimplementedAuthenticationServiceServer
// for forward compatibility
//
// Authentication Service
type AuthenticationServiceServer interface {
	Login(context.Context, *LoginRequest) (*LoginResponse, error)
	Logout(context.Context, *LogoutRequest) (*emptypb.Empty, error)
	RefreshToken(context.Context, *RefreshTokenRequest) (*RefreshTokenResponse, error)
	mustEmbedUnimplementedAuthenticationServiceServer()
}

// UnimplementedAuthenticationServiceServer must be embedded to have forward compatible implementations.
type UnimplementedAuthenticationServiceServer struct {
}

func (UnimplementedAuthenticationServiceServer) Login(context.Context, *LoginRequest) (*LoginResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Login not implemented")
}
func (UnimplementedAuthenticationServiceServer) Logout(context.Context, *LogoutRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Logout not implemented")
}
func (UnimplementedAuthenticationServiceServer) RefreshToken(context.Context, *RefreshTokenRequest) (*RefreshTokenResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RefreshToken not implemented")
}
func (UnimplementedAuthenticationServiceServer) mustEmbedUnimplementedAuthenticationServiceServer() {}

// UnsafeAuthenticationServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to AuthenticationServiceServer will
// result in compilation errors.
type UnsafeAuthenticationServiceServer interface {
	mustEmbedUnimplementedAuthenticationServiceServer()
}

func RegisterAuthenticationServiceServer(s grpc.ServiceRegistrar, srv AuthenticationServiceServer) {
	s.RegisterService(&AuthenticationService_ServiceDesc, srv)
}

func _AuthenticationService_Login_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LoginRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthenticationServiceServer).Login(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AuthenticationService_Login_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthenticationServiceServer).Login(ctx, req.(*LoginRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthenticationService_Logout_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LogoutRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthenticationServiceServer).Logout(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AuthenticationService_Logout_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthenticationServiceServer).Logout(ctx, req.(*LogoutRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthenticationService_RefreshToken_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RefreshTokenRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthenticationServiceServer).RefreshToken(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AuthenticationService_RefreshToken_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthenticationServiceServer).RefreshToken(ctx, req.(*RefreshTokenRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// AuthenticationService_ServiceDesc is the grpc.ServiceDesc for AuthenticationService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var AuthenticationService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "auth.AuthenticationService",
	HandlerType: (*AuthenticationServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Login",
			Handler:    _AuthenticationService_Login_Handler,
		},
		{
			MethodName: "Logout",
			Handler:    _AuthenticationService_Logout_Handler,
		},
		{
			MethodName: "RefreshToken",
			Handler:    _AuthenticationService_RefreshToken_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "internal/proto/speech.proto",
}

const (
	EmailService_SendVerificationEmail_FullMethodName = "/auth.EmailService/SendVerificationEmail"
	EmailService_VerifyEmail_FullMethodName           = "/auth.EmailService/VerifyEmail"
)

// EmailServiceClient is the client API for EmailService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// Email Service
type EmailServiceClient interface {
	SendVerificationEmail(ctx context.Context, in *SendVerificationEmailRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	VerifyEmail(ctx context.Context, in *VerifyEmailRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type emailServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewEmailServiceClient(cc grpc.ClientConnInterface) EmailServiceClient {
	return &emailServiceClient{cc}
}

func (c *emailServiceClient) SendVerificationEmail(ctx context.Context, in *SendVerificationEmailRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, EmailService_SendVerificationEmail_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *emailServiceClient) VerifyEmail(ctx context.Context, in *VerifyEmailRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, EmailService_VerifyEmail_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// EmailServiceServer is the server API for EmailService service.
// All implementations must embed UnimplementedEmailServiceServer
// for forward compatibility
//
// Email Service
type EmailServiceServer interface {
	SendVerificationEmail(context.Context, *SendVerificationEmailRequest) (*emptypb.Empty, error)
	VerifyEmail(context.Context, *VerifyEmailRequest) (*emptypb.Empty, error)
	mustEmbedUnimplementedEmailServiceServer()
}

// UnimplementedEmailServiceServer must be embedded to have forward compatible implementations.
type UnimplementedEmailServiceServer struct {
}

func (UnimplementedEmailServiceServer) SendVerificationEmail(context.Context, *SendVerificationEmailRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SendVerificationEmail not implemented")
}
func (UnimplementedEmailServiceServer) VerifyEmail(context.Context, *VerifyEmailRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method VerifyEmail not implemented")
}
func (UnimplementedEmailServiceServer) mustEmbedUnimplementedEmailServiceServer() {}

// UnsafeEmailServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to EmailServiceServer will
// result in compilation errors.
type UnsafeEmailServiceServer interface {
	mustEmbedUnimplementedEmailServiceServer()
}

func RegisterEmailServiceServer(s grpc.ServiceRegistrar, srv EmailServiceServer) {
	s.RegisterService(&EmailService_ServiceDesc, srv)
}

func _EmailService_SendVerificationEmail_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SendVerificationEmailRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EmailServiceServer).SendVerificationEmail(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: EmailService_SendVerificationEmail_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EmailServiceServer).SendVerificationEmail(ctx, req.(*SendVerificationEmailRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EmailService_VerifyEmail_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(VerifyEmailRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EmailServiceServer).VerifyEmail(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: EmailService_VerifyEmail_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EmailServiceServer).VerifyEmail(ctx, req.(*VerifyEmailRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// EmailService_ServiceDesc is the grpc.ServiceDesc for EmailService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var EmailService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "auth.EmailService",
	HandlerType: (*EmailServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "SendVerificationEmail",
			Handler:    _EmailService_SendVerificationEmail_Handler,
		},
		{
			MethodName: "VerifyEmail",
			Handler:    _EmailService_VerifyEmail_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "internal/proto/speech.proto",
}

const (
	PasswordService_RequestPasswordReset_FullMethodName = "/auth.PasswordService/RequestPasswordReset"
	PasswordService_ResetPassword_FullMethodName        = "/auth.PasswordService/ResetPassword"
)

// PasswordServiceClient is the client API for PasswordService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// Password Service
type PasswordServiceClient interface {
	RequestPasswordReset(ctx context.Context, in *RequestPasswordResetRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	ResetPassword(ctx context.Context, in *ResetPasswordRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type passwordServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewPasswordServiceClient(cc grpc.ClientConnInterface) PasswordServiceClient {
	return &passwordServiceClient{cc}
}

func (c *passwordServiceClient) RequestPasswordReset(ctx context.Context, in *RequestPasswordResetRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, PasswordService_RequestPasswordReset_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *passwordServiceClient) ResetPassword(ctx context.Context, in *ResetPasswordRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, PasswordService_ResetPassword_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// PasswordServiceServer is the server API for PasswordService service.
// All implementations must embed UnimplementedPasswordServiceServer
// for forward compatibility
//
// Password Service
type PasswordServiceServer interface {
	RequestPasswordReset(context.Context, *RequestPasswordResetRequest) (*emptypb.Empty, error)
	ResetPassword(context.Context, *ResetPasswordRequest) (*emptypb.Empty, error)
	mustEmbedUnimplementedPasswordServiceServer()
}

// UnimplementedPasswordServiceServer must be embedded to have forward compatible implementations.
type UnimplementedPasswordServiceServer struct {
}

func (UnimplementedPasswordServiceServer) RequestPasswordReset(context.Context, *RequestPasswordResetRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RequestPasswordReset not implemented")
}
func (UnimplementedPasswordServiceServer) ResetPassword(context.Context, *ResetPasswordRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ResetPassword not implemented")
}
func (UnimplementedPasswordServiceServer) mustEmbedUnimplementedPasswordServiceServer() {}

// UnsafePasswordServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to PasswordServiceServer will
// result in compilation errors.
type UnsafePasswordServiceServer interface {
	mustEmbedUnimplementedPasswordServiceServer()
}

func RegisterPasswordServiceServer(s grpc.ServiceRegistrar, srv PasswordServiceServer) {
	s.RegisterService(&PasswordService_ServiceDesc, srv)
}

func _PasswordService_RequestPasswordReset_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RequestPasswordResetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PasswordServiceServer).RequestPasswordReset(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PasswordService_RequestPasswordReset_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PasswordServiceServer).RequestPasswordReset(ctx, req.(*RequestPasswordResetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PasswordService_ResetPassword_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ResetPasswordRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PasswordServiceServer).ResetPassword(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PasswordService_ResetPassword_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PasswordServiceServer).ResetPassword(ctx, req.(*ResetPasswordRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// PasswordService_ServiceDesc is the grpc.ServiceDesc for PasswordService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var PasswordService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "auth.PasswordService",
	HandlerType: (*PasswordServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "RequestPasswordReset",
			Handler:    _PasswordService_RequestPasswordReset_Handler,
		},
		{
			MethodName: "ResetPassword",
			Handler:    _PasswordService_ResetPassword_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "internal/proto/speech.proto",
}

const (
	SessionManagementService_GetUserSessions_FullMethodName = "/auth.SessionManagementService/GetUserSessions"
	SessionManagementService_DeleteSession_FullMethodName   = "/auth.SessionManagementService/DeleteSession"
)

// SessionManagementServiceClient is the client API for SessionManagementService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// Session Management Service
type SessionManagementServiceClient interface {
	GetUserSessions(ctx context.Context, in *GetUserSessionsRequest, opts ...grpc.CallOption) (*GetUserSessionsResponse, error)
	DeleteSession(ctx context.Context, in *DeleteSessionRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type sessionManagementServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewSessionManagementServiceClient(cc grpc.ClientConnInterface) SessionManagementServiceClient {
	return &sessionManagementServiceClient{cc}
}

func (c *sessionManagementServiceClient) GetUserSessions(ctx context.Context, in *GetUserSessionsRequest, opts ...grpc.CallOption) (*GetUserSessionsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetUserSessionsResponse)
	err := c.cc.Invoke(ctx, SessionManagementService_GetUserSessions_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *sessionManagementServiceClient) DeleteSession(ctx context.Context, in *DeleteSessionRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, SessionManagementService_DeleteSession_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// SessionManagementServiceServer is the server API for SessionManagementService service.
// All implementations must embed UnimplementedSessionManagementServiceServer
// for forward compatibility
//
// Session Management Service
type SessionManagementServiceServer interface {
	GetUserSessions(context.Context, *GetUserSessionsRequest) (*GetUserSessionsResponse, error)
	DeleteSession(context.Context, *DeleteSessionRequest) (*emptypb.Empty, error)
	mustEmbedUnimplementedSessionManagementServiceServer()
}

// UnimplementedSessionManagementServiceServer must be embedded to have forward compatible implementations.
type UnimplementedSessionManagementServiceServer struct {
}

func (UnimplementedSessionManagementServiceServer) GetUserSessions(context.Context, *GetUserSessionsRequest) (*GetUserSessionsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetUserSessions not implemented")
}
func (UnimplementedSessionManagementServiceServer) DeleteSession(context.Context, *DeleteSessionRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteSession not implemented")
}
func (UnimplementedSessionManagementServiceServer) mustEmbedUnimplementedSessionManagementServiceServer() {
}

// UnsafeSessionManagementServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to SessionManagementServiceServer will
// result in compilation errors.
type UnsafeSessionManagementServiceServer interface {
	mustEmbedUnimplementedSessionManagementServiceServer()
}

func RegisterSessionManagementServiceServer(s grpc.ServiceRegistrar, srv SessionManagementServiceServer) {
	s.RegisterService(&SessionManagementService_ServiceDesc, srv)
}

func _SessionManagementService_GetUserSessions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetUserSessionsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SessionManagementServiceServer).GetUserSessions(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SessionManagementService_GetUserSessions_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SessionManagementServiceServer).GetUserSessions(ctx, req.(*GetUserSessionsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SessionManagementService_DeleteSession_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteSessionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SessionManagementServiceServer).DeleteSession(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SessionManagementService_DeleteSession_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SessionManagementServiceServer).DeleteSession(ctx, req.(*DeleteSessionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// SessionManagementService_ServiceDesc is the grpc.ServiceDesc for SessionManagementService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var SessionManagementService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "auth.SessionManagementService",
	HandlerType: (*SessionManagementServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetUserSessions",
			Handler:    _SessionManagementService_GetUserSessions_Handler,
		},
		{
			MethodName: "DeleteSession",
			Handler:    _SessionManagementService_DeleteSession_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "internal/proto/speech.proto",
}

const (
	UserRoleService_GetUserRoles_FullMethodName   = "/auth.UserRoleService/GetUserRoles"
	UserRoleService_AddUserRole_FullMethodName    = "/auth.UserRoleService/AddUserRole"
	UserRoleService_RemoveUserRole_FullMethodName = "/auth.UserRoleService/RemoveUserRole"
)

// UserRoleServiceClient is the client API for UserRoleService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// User Role Service
type UserRoleServiceClient interface {
	GetUserRoles(ctx context.Context, in *GetUserRolesRequest, opts ...grpc.CallOption) (*GetUserRolesResponse, error)
	AddUserRole(ctx context.Context, in *AddUserRoleRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	RemoveUserRole(ctx context.Context, in *RemoveUserRoleRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type userRoleServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewUserRoleServiceClient(cc grpc.ClientConnInterface) UserRoleServiceClient {
	return &userRoleServiceClient{cc}
}

func (c *userRoleServiceClient) GetUserRoles(ctx context.Context, in *GetUserRolesRequest, opts ...grpc.CallOption) (*GetUserRolesResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetUserRolesResponse)
	err := c.cc.Invoke(ctx, UserRoleService_GetUserRoles_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userRoleServiceClient) AddUserRole(ctx context.Context, in *AddUserRoleRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, UserRoleService_AddUserRole_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userRoleServiceClient) RemoveUserRole(ctx context.Context, in *RemoveUserRoleRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, UserRoleService_RemoveUserRole_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// UserRoleServiceServer is the server API for UserRoleService service.
// All implementations must embed UnimplementedUserRoleServiceServer
// for forward compatibility
//
// User Role Service
type UserRoleServiceServer interface {
	GetUserRoles(context.Context, *GetUserRolesRequest) (*GetUserRolesResponse, error)
	AddUserRole(context.Context, *AddUserRoleRequest) (*emptypb.Empty, error)
	RemoveUserRole(context.Context, *RemoveUserRoleRequest) (*emptypb.Empty, error)
	mustEmbedUnimplementedUserRoleServiceServer()
}

// UnimplementedUserRoleServiceServer must be embedded to have forward compatible implementations.
type UnimplementedUserRoleServiceServer struct {
}

func (UnimplementedUserRoleServiceServer) GetUserRoles(context.Context, *GetUserRolesRequest) (*GetUserRolesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetUserRoles not implemented")
}
func (UnimplementedUserRoleServiceServer) AddUserRole(context.Context, *AddUserRoleRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddUserRole not implemented")
}
func (UnimplementedUserRoleServiceServer) RemoveUserRole(context.Context, *RemoveUserRoleRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RemoveUserRole not implemented")
}
func (UnimplementedUserRoleServiceServer) mustEmbedUnimplementedUserRoleServiceServer() {}

// UnsafeUserRoleServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to UserRoleServiceServer will
// result in compilation errors.
type UnsafeUserRoleServiceServer interface {
	mustEmbedUnimplementedUserRoleServiceServer()
}

func RegisterUserRoleServiceServer(s grpc.ServiceRegistrar, srv UserRoleServiceServer) {
	s.RegisterService(&UserRoleService_ServiceDesc, srv)
}

func _UserRoleService_GetUserRoles_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetUserRolesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserRoleServiceServer).GetUserRoles(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserRoleService_GetUserRoles_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserRoleServiceServer).GetUserRoles(ctx, req.(*GetUserRolesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserRoleService_AddUserRole_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddUserRoleRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserRoleServiceServer).AddUserRole(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserRoleService_AddUserRole_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserRoleServiceServer).AddUserRole(ctx, req.(*AddUserRoleRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserRoleService_RemoveUserRole_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RemoveUserRoleRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserRoleServiceServer).RemoveUserRole(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserRoleService_RemoveUserRole_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserRoleServiceServer).RemoveUserRole(ctx, req.(*RemoveUserRoleRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// UserRoleService_ServiceDesc is the grpc.ServiceDesc for UserRoleService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var UserRoleService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "auth.UserRoleService",
	HandlerType: (*UserRoleServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetUserRoles",
			Handler:    _UserRoleService_GetUserRoles_Handler,
		},
		{
			MethodName: "AddUserRole",
			Handler:    _UserRoleService_AddUserRole_Handler,
		},
		{
			MethodName: "RemoveUserRole",
			Handler:    _UserRoleService_RemoveUserRole_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "internal/proto/speech.proto",
}

const (
	AvatarService_UpdateUserAvatar_FullMethodName     = "/auth.AvatarService/UpdateUserAvatar"
	AvatarService_GetUserAvatarHistory_FullMethodName = "/auth.AvatarService/GetUserAvatarHistory"
)

// AvatarServiceClient is the client API for AvatarService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// Avatar Service
type AvatarServiceClient interface {
	UpdateUserAvatar(ctx context.Context, in *UpdateUserAvatarRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	GetUserAvatarHistory(ctx context.Context, in *GetUserAvatarHistoryRequest, opts ...grpc.CallOption) (*GetUserAvatarHistoryResponse, error)
}

type avatarServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewAvatarServiceClient(cc grpc.ClientConnInterface) AvatarServiceClient {
	return &avatarServiceClient{cc}
}

func (c *avatarServiceClient) UpdateUserAvatar(ctx context.Context, in *UpdateUserAvatarRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, AvatarService_UpdateUserAvatar_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *avatarServiceClient) GetUserAvatarHistory(ctx context.Context, in *GetUserAvatarHistoryRequest, opts ...grpc.CallOption) (*GetUserAvatarHistoryResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetUserAvatarHistoryResponse)
	err := c.cc.Invoke(ctx, AvatarService_GetUserAvatarHistory_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// AvatarServiceServer is the server API for AvatarService service.
// All implementations must embed UnimplementedAvatarServiceServer
// for forward compatibility
//
// Avatar Service
type AvatarServiceServer interface {
	UpdateUserAvatar(context.Context, *UpdateUserAvatarRequest) (*emptypb.Empty, error)
	GetUserAvatarHistory(context.Context, *GetUserAvatarHistoryRequest) (*GetUserAvatarHistoryResponse, error)
	mustEmbedUnimplementedAvatarServiceServer()
}

// UnimplementedAvatarServiceServer must be embedded to have forward compatible implementations.
type UnimplementedAvatarServiceServer struct {
}

func (UnimplementedAvatarServiceServer) UpdateUserAvatar(context.Context, *UpdateUserAvatarRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateUserAvatar not implemented")
}
func (UnimplementedAvatarServiceServer) GetUserAvatarHistory(context.Context, *GetUserAvatarHistoryRequest) (*GetUserAvatarHistoryResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetUserAvatarHistory not implemented")
}
func (UnimplementedAvatarServiceServer) mustEmbedUnimplementedAvatarServiceServer() {}

// UnsafeAvatarServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to AvatarServiceServer will
// result in compilation errors.
type UnsafeAvatarServiceServer interface {
	mustEmbedUnimplementedAvatarServiceServer()
}

func RegisterAvatarServiceServer(s grpc.ServiceRegistrar, srv AvatarServiceServer) {
	s.RegisterService(&AvatarService_ServiceDesc, srv)
}

func _AvatarService_UpdateUserAvatar_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateUserAvatarRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AvatarServiceServer).UpdateUserAvatar(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AvatarService_UpdateUserAvatar_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AvatarServiceServer).UpdateUserAvatar(ctx, req.(*UpdateUserAvatarRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AvatarService_GetUserAvatarHistory_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetUserAvatarHistoryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AvatarServiceServer).GetUserAvatarHistory(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AvatarService_GetUserAvatarHistory_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AvatarServiceServer).GetUserAvatarHistory(ctx, req.(*GetUserAvatarHistoryRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// AvatarService_ServiceDesc is the grpc.ServiceDesc for AvatarService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var AvatarService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "auth.AvatarService",
	HandlerType: (*AvatarServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "UpdateUserAvatar",
			Handler:    _AvatarService_UpdateUserAvatar_Handler,
		},
		{
			MethodName: "GetUserAvatarHistory",
			Handler:    _AvatarService_GetUserAvatarHistory_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "internal/proto/speech.proto",
}

const (
	KeyManagementService_UpdateUserKeys_FullMethodName = "/auth.KeyManagementService/UpdateUserKeys"
	KeyManagementService_VerifyUserKey_FullMethodName  = "/auth.KeyManagementService/VerifyUserKey"
)

// KeyManagementServiceClient is the client API for KeyManagementService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// Key Management Service
type KeyManagementServiceClient interface {
	UpdateUserKeys(ctx context.Context, in *UpdateUserKeysRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	VerifyUserKey(ctx context.Context, in *VerifyUserKeyRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type keyManagementServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewKeyManagementServiceClient(cc grpc.ClientConnInterface) KeyManagementServiceClient {
	return &keyManagementServiceClient{cc}
}

func (c *keyManagementServiceClient) UpdateUserKeys(ctx context.Context, in *UpdateUserKeysRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, KeyManagementService_UpdateUserKeys_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *keyManagementServiceClient) VerifyUserKey(ctx context.Context, in *VerifyUserKeyRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, KeyManagementService_VerifyUserKey_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// KeyManagementServiceServer is the server API for KeyManagementService service.
// All implementations must embed UnimplementedKeyManagementServiceServer
// for forward compatibility
//
// Key Management Service
type KeyManagementServiceServer interface {
	UpdateUserKeys(context.Context, *UpdateUserKeysRequest) (*emptypb.Empty, error)
	VerifyUserKey(context.Context, *VerifyUserKeyRequest) (*emptypb.Empty, error)
	mustEmbedUnimplementedKeyManagementServiceServer()
}

// UnimplementedKeyManagementServiceServer must be embedded to have forward compatible implementations.
type UnimplementedKeyManagementServiceServer struct {
}

func (UnimplementedKeyManagementServiceServer) UpdateUserKeys(context.Context, *UpdateUserKeysRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateUserKeys not implemented")
}
func (UnimplementedKeyManagementServiceServer) VerifyUserKey(context.Context, *VerifyUserKeyRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method VerifyUserKey not implemented")
}
func (UnimplementedKeyManagementServiceServer) mustEmbedUnimplementedKeyManagementServiceServer() {}

// UnsafeKeyManagementServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to KeyManagementServiceServer will
// result in compilation errors.
type UnsafeKeyManagementServiceServer interface {
	mustEmbedUnimplementedKeyManagementServiceServer()
}

func RegisterKeyManagementServiceServer(s grpc.ServiceRegistrar, srv KeyManagementServiceServer) {
	s.RegisterService(&KeyManagementService_ServiceDesc, srv)
}

func _KeyManagementService_UpdateUserKeys_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateUserKeysRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KeyManagementServiceServer).UpdateUserKeys(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: KeyManagementService_UpdateUserKeys_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KeyManagementServiceServer).UpdateUserKeys(ctx, req.(*UpdateUserKeysRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _KeyManagementService_VerifyUserKey_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(VerifyUserKeyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KeyManagementServiceServer).VerifyUserKey(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: KeyManagementService_VerifyUserKey_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KeyManagementServiceServer).VerifyUserKey(ctx, req.(*VerifyUserKeyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// KeyManagementService_ServiceDesc is the grpc.ServiceDesc for KeyManagementService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var KeyManagementService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "auth.KeyManagementService",
	HandlerType: (*KeyManagementServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "UpdateUserKeys",
			Handler:    _KeyManagementService_UpdateUserKeys_Handler,
		},
		{
			MethodName: "VerifyUserKey",
			Handler:    _KeyManagementService_VerifyUserKey_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "internal/proto/speech.proto",
}

const (
	DeviceManagementService_RevokeDevice_FullMethodName = "/auth.DeviceManagementService/RevokeDevice"
)

// DeviceManagementServiceClient is the client API for DeviceManagementService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// Device Management Service
type DeviceManagementServiceClient interface {
	RevokeDevice(ctx context.Context, in *RevokeDeviceRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type deviceManagementServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewDeviceManagementServiceClient(cc grpc.ClientConnInterface) DeviceManagementServiceClient {
	return &deviceManagementServiceClient{cc}
}

func (c *deviceManagementServiceClient) RevokeDevice(ctx context.Context, in *RevokeDeviceRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, DeviceManagementService_RevokeDevice_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// DeviceManagementServiceServer is the server API for DeviceManagementService service.
// All implementations must embed UnimplementedDeviceManagementServiceServer
// for forward compatibility
//
// Device Management Service
type DeviceManagementServiceServer interface {
	RevokeDevice(context.Context, *RevokeDeviceRequest) (*emptypb.Empty, error)
	mustEmbedUnimplementedDeviceManagementServiceServer()
}

// UnimplementedDeviceManagementServiceServer must be embedded to have forward compatible implementations.
type UnimplementedDeviceManagementServiceServer struct {
}

func (UnimplementedDeviceManagementServiceServer) RevokeDevice(context.Context, *RevokeDeviceRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RevokeDevice not implemented")
}
func (UnimplementedDeviceManagementServiceServer) mustEmbedUnimplementedDeviceManagementServiceServer() {
}

// UnsafeDeviceManagementServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to DeviceManagementServiceServer will
// result in compilation errors.
type UnsafeDeviceManagementServiceServer interface {
	mustEmbedUnimplementedDeviceManagementServiceServer()
}

func RegisterDeviceManagementServiceServer(s grpc.ServiceRegistrar, srv DeviceManagementServiceServer) {
	s.RegisterService(&DeviceManagementService_ServiceDesc, srv)
}

func _DeviceManagementService_RevokeDevice_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RevokeDeviceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DeviceManagementServiceServer).RevokeDevice(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DeviceManagementService_RevokeDevice_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DeviceManagementServiceServer).RevokeDevice(ctx, req.(*RevokeDeviceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// DeviceManagementService_ServiceDesc is the grpc.ServiceDesc for DeviceManagementService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var DeviceManagementService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "auth.DeviceManagementService",
	HandlerType: (*DeviceManagementServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "RevokeDevice",
			Handler:    _DeviceManagementService_RevokeDevice_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "internal/proto/speech.proto",
}

const (
	AccountRecoveryService_InitiateAccountRecovery_FullMethodName = "/auth.AccountRecoveryService/InitiateAccountRecovery"
	AccountRecoveryService_CompleteAccountRecovery_FullMethodName = "/auth.AccountRecoveryService/CompleteAccountRecovery"
)

// AccountRecoveryServiceClient is the client API for AccountRecoveryService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// Account Recovery Service
type AccountRecoveryServiceClient interface {
	InitiateAccountRecovery(ctx context.Context, in *InitiateAccountRecoveryRequest, opts ...grpc.CallOption) (*InitiateAccountRecoveryResponse, error)
	CompleteAccountRecovery(ctx context.Context, in *CompleteAccountRecoveryRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type accountRecoveryServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewAccountRecoveryServiceClient(cc grpc.ClientConnInterface) AccountRecoveryServiceClient {
	return &accountRecoveryServiceClient{cc}
}

func (c *accountRecoveryServiceClient) InitiateAccountRecovery(ctx context.Context, in *InitiateAccountRecoveryRequest, opts ...grpc.CallOption) (*InitiateAccountRecoveryResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(InitiateAccountRecoveryResponse)
	err := c.cc.Invoke(ctx, AccountRecoveryService_InitiateAccountRecovery_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *accountRecoveryServiceClient) CompleteAccountRecovery(ctx context.Context, in *CompleteAccountRecoveryRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, AccountRecoveryService_CompleteAccountRecovery_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// AccountRecoveryServiceServer is the server API for AccountRecoveryService service.
// All implementations must embed UnimplementedAccountRecoveryServiceServer
// for forward compatibility
//
// Account Recovery Service
type AccountRecoveryServiceServer interface {
	InitiateAccountRecovery(context.Context, *InitiateAccountRecoveryRequest) (*InitiateAccountRecoveryResponse, error)
	CompleteAccountRecovery(context.Context, *CompleteAccountRecoveryRequest) (*emptypb.Empty, error)
	mustEmbedUnimplementedAccountRecoveryServiceServer()
}

// UnimplementedAccountRecoveryServiceServer must be embedded to have forward compatible implementations.
type UnimplementedAccountRecoveryServiceServer struct {
}

func (UnimplementedAccountRecoveryServiceServer) InitiateAccountRecovery(context.Context, *InitiateAccountRecoveryRequest) (*InitiateAccountRecoveryResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method InitiateAccountRecovery not implemented")
}
func (UnimplementedAccountRecoveryServiceServer) CompleteAccountRecovery(context.Context, *CompleteAccountRecoveryRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CompleteAccountRecovery not implemented")
}
func (UnimplementedAccountRecoveryServiceServer) mustEmbedUnimplementedAccountRecoveryServiceServer() {
}

// UnsafeAccountRecoveryServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to AccountRecoveryServiceServer will
// result in compilation errors.
type UnsafeAccountRecoveryServiceServer interface {
	mustEmbedUnimplementedAccountRecoveryServiceServer()
}

func RegisterAccountRecoveryServiceServer(s grpc.ServiceRegistrar, srv AccountRecoveryServiceServer) {
	s.RegisterService(&AccountRecoveryService_ServiceDesc, srv)
}

func _AccountRecoveryService_InitiateAccountRecovery_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InitiateAccountRecoveryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AccountRecoveryServiceServer).InitiateAccountRecovery(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AccountRecoveryService_InitiateAccountRecovery_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AccountRecoveryServiceServer).InitiateAccountRecovery(ctx, req.(*InitiateAccountRecoveryRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AccountRecoveryService_CompleteAccountRecovery_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CompleteAccountRecoveryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AccountRecoveryServiceServer).CompleteAccountRecovery(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AccountRecoveryService_CompleteAccountRecovery_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AccountRecoveryServiceServer).CompleteAccountRecovery(ctx, req.(*CompleteAccountRecoveryRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// AccountRecoveryService_ServiceDesc is the grpc.ServiceDesc for AccountRecoveryService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var AccountRecoveryService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "auth.AccountRecoveryService",
	HandlerType: (*AccountRecoveryServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "InitiateAccountRecovery",
			Handler:    _AccountRecoveryService_InitiateAccountRecovery_Handler,
		},
		{
			MethodName: "CompleteAccountRecovery",
			Handler:    _AccountRecoveryService_CompleteAccountRecovery_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "internal/proto/speech.proto",
}

const (
	UserStatusService_StreamUserStatus_FullMethodName = "/auth.UserStatusService/StreamUserStatus"
)

// UserStatusServiceClient is the client API for UserStatusService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// User Status Service
type UserStatusServiceClient interface {
	StreamUserStatus(ctx context.Context, opts ...grpc.CallOption) (UserStatusService_StreamUserStatusClient, error)
}

type userStatusServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewUserStatusServiceClient(cc grpc.ClientConnInterface) UserStatusServiceClient {
	return &userStatusServiceClient{cc}
}

func (c *userStatusServiceClient) StreamUserStatus(ctx context.Context, opts ...grpc.CallOption) (UserStatusService_StreamUserStatusClient, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &UserStatusService_ServiceDesc.Streams[0], UserStatusService_StreamUserStatus_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &userStatusServiceStreamUserStatusClient{ClientStream: stream}
	return x, nil
}

type UserStatusService_StreamUserStatusClient interface {
	Send(*UserStatusUpdate) error
	Recv() (*UserStatusUpdate, error)
	grpc.ClientStream
}

type userStatusServiceStreamUserStatusClient struct {
	grpc.ClientStream
}

func (x *userStatusServiceStreamUserStatusClient) Send(m *UserStatusUpdate) error {
	return x.ClientStream.SendMsg(m)
}

func (x *userStatusServiceStreamUserStatusClient) Recv() (*UserStatusUpdate, error) {
	m := new(UserStatusUpdate)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// UserStatusServiceServer is the server API for UserStatusService service.
// All implementations must embed UnimplementedUserStatusServiceServer
// for forward compatibility
//
// User Status Service
type UserStatusServiceServer interface {
	StreamUserStatus(UserStatusService_StreamUserStatusServer) error
	mustEmbedUnimplementedUserStatusServiceServer()
}

// UnimplementedUserStatusServiceServer must be embedded to have forward compatible implementations.
type UnimplementedUserStatusServiceServer struct {
}

func (UnimplementedUserStatusServiceServer) StreamUserStatus(UserStatusService_StreamUserStatusServer) error {
	return status.Errorf(codes.Unimplemented, "method StreamUserStatus not implemented")
}
func (UnimplementedUserStatusServiceServer) mustEmbedUnimplementedUserStatusServiceServer() {}

// UnsafeUserStatusServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to UserStatusServiceServer will
// result in compilation errors.
type UnsafeUserStatusServiceServer interface {
	mustEmbedUnimplementedUserStatusServiceServer()
}

func RegisterUserStatusServiceServer(s grpc.ServiceRegistrar, srv UserStatusServiceServer) {
	s.RegisterService(&UserStatusService_ServiceDesc, srv)
}

func _UserStatusService_StreamUserStatus_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(UserStatusServiceServer).StreamUserStatus(&userStatusServiceStreamUserStatusServer{ServerStream: stream})
}

type UserStatusService_StreamUserStatusServer interface {
	Send(*UserStatusUpdate) error
	Recv() (*UserStatusUpdate, error)
	grpc.ServerStream
}

type userStatusServiceStreamUserStatusServer struct {
	grpc.ServerStream
}

func (x *userStatusServiceStreamUserStatusServer) Send(m *UserStatusUpdate) error {
	return x.ServerStream.SendMsg(m)
}

func (x *userStatusServiceStreamUserStatusServer) Recv() (*UserStatusUpdate, error) {
	m := new(UserStatusUpdate)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// UserStatusService_ServiceDesc is the grpc.ServiceDesc for UserStatusService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var UserStatusService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "auth.UserStatusService",
	HandlerType: (*UserStatusServiceServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "StreamUserStatus",
			Handler:       _UserStatusService_StreamUserStatus_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
	Metadata: "internal/proto/speech.proto",
}

const (
	DirectMessagingService_InitiateChat_FullMethodName           = "/auth.DirectMessagingService/InitiateChat"
	DirectMessagingService_SendMessage_FullMethodName            = "/auth.DirectMessagingService/SendMessage"
	DirectMessagingService_GetMessages_FullMethodName            = "/auth.DirectMessagingService/GetMessages"
	DirectMessagingService_RequestMissingMessages_FullMethodName = "/auth.DirectMessagingService/RequestMissingMessages"
)

// DirectMessagingServiceClient is the client API for DirectMessagingService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// Direct Messaging Service
type DirectMessagingServiceClient interface {
	InitiateChat(ctx context.Context, in *InitiateChatRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	SendMessage(ctx context.Context, in *SendMessageRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	GetMessages(ctx context.Context, in *GetMessagesRequest, opts ...grpc.CallOption) (*GetMessagesResponse, error)
	RequestMissingMessages(ctx context.Context, in *RequestMissingMessagesRequest, opts ...grpc.CallOption) (*GetMessagesResponse, error)
}

type directMessagingServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewDirectMessagingServiceClient(cc grpc.ClientConnInterface) DirectMessagingServiceClient {
	return &directMessagingServiceClient{cc}
}

func (c *directMessagingServiceClient) InitiateChat(ctx context.Context, in *InitiateChatRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, DirectMessagingService_InitiateChat_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *directMessagingServiceClient) SendMessage(ctx context.Context, in *SendMessageRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, DirectMessagingService_SendMessage_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *directMessagingServiceClient) GetMessages(ctx context.Context, in *GetMessagesRequest, opts ...grpc.CallOption) (*GetMessagesResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetMessagesResponse)
	err := c.cc.Invoke(ctx, DirectMessagingService_GetMessages_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *directMessagingServiceClient) RequestMissingMessages(ctx context.Context, in *RequestMissingMessagesRequest, opts ...grpc.CallOption) (*GetMessagesResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetMessagesResponse)
	err := c.cc.Invoke(ctx, DirectMessagingService_RequestMissingMessages_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// DirectMessagingServiceServer is the server API for DirectMessagingService service.
// All implementations must embed UnimplementedDirectMessagingServiceServer
// for forward compatibility
//
// Direct Messaging Service
type DirectMessagingServiceServer interface {
	InitiateChat(context.Context, *InitiateChatRequest) (*emptypb.Empty, error)
	SendMessage(context.Context, *SendMessageRequest) (*emptypb.Empty, error)
	GetMessages(context.Context, *GetMessagesRequest) (*GetMessagesResponse, error)
	RequestMissingMessages(context.Context, *RequestMissingMessagesRequest) (*GetMessagesResponse, error)
	mustEmbedUnimplementedDirectMessagingServiceServer()
}

// UnimplementedDirectMessagingServiceServer must be embedded to have forward compatible implementations.
type UnimplementedDirectMessagingServiceServer struct {
}

func (UnimplementedDirectMessagingServiceServer) InitiateChat(context.Context, *InitiateChatRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method InitiateChat not implemented")
}
func (UnimplementedDirectMessagingServiceServer) SendMessage(context.Context, *SendMessageRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SendMessage not implemented")
}
func (UnimplementedDirectMessagingServiceServer) GetMessages(context.Context, *GetMessagesRequest) (*GetMessagesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetMessages not implemented")
}
func (UnimplementedDirectMessagingServiceServer) RequestMissingMessages(context.Context, *RequestMissingMessagesRequest) (*GetMessagesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RequestMissingMessages not implemented")
}
func (UnimplementedDirectMessagingServiceServer) mustEmbedUnimplementedDirectMessagingServiceServer() {
}

// UnsafeDirectMessagingServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to DirectMessagingServiceServer will
// result in compilation errors.
type UnsafeDirectMessagingServiceServer interface {
	mustEmbedUnimplementedDirectMessagingServiceServer()
}

func RegisterDirectMessagingServiceServer(s grpc.ServiceRegistrar, srv DirectMessagingServiceServer) {
	s.RegisterService(&DirectMessagingService_ServiceDesc, srv)
}

func _DirectMessagingService_InitiateChat_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InitiateChatRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DirectMessagingServiceServer).InitiateChat(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DirectMessagingService_InitiateChat_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DirectMessagingServiceServer).InitiateChat(ctx, req.(*InitiateChatRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DirectMessagingService_SendMessage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SendMessageRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DirectMessagingServiceServer).SendMessage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DirectMessagingService_SendMessage_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DirectMessagingServiceServer).SendMessage(ctx, req.(*SendMessageRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DirectMessagingService_GetMessages_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetMessagesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DirectMessagingServiceServer).GetMessages(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DirectMessagingService_GetMessages_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DirectMessagingServiceServer).GetMessages(ctx, req.(*GetMessagesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DirectMessagingService_RequestMissingMessages_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RequestMissingMessagesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DirectMessagingServiceServer).RequestMissingMessages(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DirectMessagingService_RequestMissingMessages_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DirectMessagingServiceServer).RequestMissingMessages(ctx, req.(*RequestMissingMessagesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// DirectMessagingService_ServiceDesc is the grpc.ServiceDesc for DirectMessagingService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var DirectMessagingService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "auth.DirectMessagingService",
	HandlerType: (*DirectMessagingServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "InitiateChat",
			Handler:    _DirectMessagingService_InitiateChat_Handler,
		},
		{
			MethodName: "SendMessage",
			Handler:    _DirectMessagingService_SendMessage_Handler,
		},
		{
			MethodName: "GetMessages",
			Handler:    _DirectMessagingService_GetMessages_Handler,
		},
		{
			MethodName: "RequestMissingMessages",
			Handler:    _DirectMessagingService_RequestMissingMessages_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "internal/proto/speech.proto",
}

const (
	GroupChatService_CreateGroup_FullMethodName                 = "/auth.GroupChatService/CreateGroup"
	GroupChatService_SendGroupMessage_FullMethodName            = "/auth.GroupChatService/SendGroupMessage"
	GroupChatService_UpdateGroupKey_FullMethodName              = "/auth.GroupChatService/UpdateGroupKey"
	GroupChatService_AddGroupMember_FullMethodName              = "/auth.GroupChatService/AddGroupMember"
	GroupChatService_RemoveGroupMember_FullMethodName           = "/auth.GroupChatService/RemoveGroupMember"
	GroupChatService_RequestMissingGroupMessages_FullMethodName = "/auth.GroupChatService/RequestMissingGroupMessages"
)

// GroupChatServiceClient is the client API for GroupChatService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// Group Chat Service
type GroupChatServiceClient interface {
	CreateGroup(ctx context.Context, in *CreateGroupRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	SendGroupMessage(ctx context.Context, in *GroupMessageRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	UpdateGroupKey(ctx context.Context, in *UpdateGroupKeyRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	AddGroupMember(ctx context.Context, in *AddGroupMemberRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	RemoveGroupMember(ctx context.Context, in *RemoveGroupMemberRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	RequestMissingGroupMessages(ctx context.Context, in *RequestMissingGroupMessagesRequest, opts ...grpc.CallOption) (*GetMessagesResponse, error)
}

type groupChatServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewGroupChatServiceClient(cc grpc.ClientConnInterface) GroupChatServiceClient {
	return &groupChatServiceClient{cc}
}

func (c *groupChatServiceClient) CreateGroup(ctx context.Context, in *CreateGroupRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, GroupChatService_CreateGroup_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *groupChatServiceClient) SendGroupMessage(ctx context.Context, in *GroupMessageRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, GroupChatService_SendGroupMessage_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *groupChatServiceClient) UpdateGroupKey(ctx context.Context, in *UpdateGroupKeyRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, GroupChatService_UpdateGroupKey_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *groupChatServiceClient) AddGroupMember(ctx context.Context, in *AddGroupMemberRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, GroupChatService_AddGroupMember_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *groupChatServiceClient) RemoveGroupMember(ctx context.Context, in *RemoveGroupMemberRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, GroupChatService_RemoveGroupMember_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *groupChatServiceClient) RequestMissingGroupMessages(ctx context.Context, in *RequestMissingGroupMessagesRequest, opts ...grpc.CallOption) (*GetMessagesResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetMessagesResponse)
	err := c.cc.Invoke(ctx, GroupChatService_RequestMissingGroupMessages_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// GroupChatServiceServer is the server API for GroupChatService service.
// All implementations must embed UnimplementedGroupChatServiceServer
// for forward compatibility
//
// Group Chat Service
type GroupChatServiceServer interface {
	CreateGroup(context.Context, *CreateGroupRequest) (*emptypb.Empty, error)
	SendGroupMessage(context.Context, *GroupMessageRequest) (*emptypb.Empty, error)
	UpdateGroupKey(context.Context, *UpdateGroupKeyRequest) (*emptypb.Empty, error)
	AddGroupMember(context.Context, *AddGroupMemberRequest) (*emptypb.Empty, error)
	RemoveGroupMember(context.Context, *RemoveGroupMemberRequest) (*emptypb.Empty, error)
	RequestMissingGroupMessages(context.Context, *RequestMissingGroupMessagesRequest) (*GetMessagesResponse, error)
	mustEmbedUnimplementedGroupChatServiceServer()
}

// UnimplementedGroupChatServiceServer must be embedded to have forward compatible implementations.
type UnimplementedGroupChatServiceServer struct {
}

func (UnimplementedGroupChatServiceServer) CreateGroup(context.Context, *CreateGroupRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateGroup not implemented")
}
func (UnimplementedGroupChatServiceServer) SendGroupMessage(context.Context, *GroupMessageRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SendGroupMessage not implemented")
}
func (UnimplementedGroupChatServiceServer) UpdateGroupKey(context.Context, *UpdateGroupKeyRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateGroupKey not implemented")
}
func (UnimplementedGroupChatServiceServer) AddGroupMember(context.Context, *AddGroupMemberRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddGroupMember not implemented")
}
func (UnimplementedGroupChatServiceServer) RemoveGroupMember(context.Context, *RemoveGroupMemberRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RemoveGroupMember not implemented")
}
func (UnimplementedGroupChatServiceServer) RequestMissingGroupMessages(context.Context, *RequestMissingGroupMessagesRequest) (*GetMessagesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RequestMissingGroupMessages not implemented")
}
func (UnimplementedGroupChatServiceServer) mustEmbedUnimplementedGroupChatServiceServer() {}

// UnsafeGroupChatServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to GroupChatServiceServer will
// result in compilation errors.
type UnsafeGroupChatServiceServer interface {
	mustEmbedUnimplementedGroupChatServiceServer()
}

func RegisterGroupChatServiceServer(s grpc.ServiceRegistrar, srv GroupChatServiceServer) {
	s.RegisterService(&GroupChatService_ServiceDesc, srv)
}

func _GroupChatService_CreateGroup_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateGroupRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GroupChatServiceServer).CreateGroup(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: GroupChatService_CreateGroup_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GroupChatServiceServer).CreateGroup(ctx, req.(*CreateGroupRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GroupChatService_SendGroupMessage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GroupMessageRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GroupChatServiceServer).SendGroupMessage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: GroupChatService_SendGroupMessage_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GroupChatServiceServer).SendGroupMessage(ctx, req.(*GroupMessageRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GroupChatService_UpdateGroupKey_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateGroupKeyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GroupChatServiceServer).UpdateGroupKey(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: GroupChatService_UpdateGroupKey_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GroupChatServiceServer).UpdateGroupKey(ctx, req.(*UpdateGroupKeyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GroupChatService_AddGroupMember_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddGroupMemberRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GroupChatServiceServer).AddGroupMember(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: GroupChatService_AddGroupMember_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GroupChatServiceServer).AddGroupMember(ctx, req.(*AddGroupMemberRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GroupChatService_RemoveGroupMember_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RemoveGroupMemberRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GroupChatServiceServer).RemoveGroupMember(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: GroupChatService_RemoveGroupMember_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GroupChatServiceServer).RemoveGroupMember(ctx, req.(*RemoveGroupMemberRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GroupChatService_RequestMissingGroupMessages_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RequestMissingGroupMessagesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GroupChatServiceServer).RequestMissingGroupMessages(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: GroupChatService_RequestMissingGroupMessages_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GroupChatServiceServer).RequestMissingGroupMessages(ctx, req.(*RequestMissingGroupMessagesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// GroupChatService_ServiceDesc is the grpc.ServiceDesc for GroupChatService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var GroupChatService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "auth.GroupChatService",
	HandlerType: (*GroupChatServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateGroup",
			Handler:    _GroupChatService_CreateGroup_Handler,
		},
		{
			MethodName: "SendGroupMessage",
			Handler:    _GroupChatService_SendGroupMessage_Handler,
		},
		{
			MethodName: "UpdateGroupKey",
			Handler:    _GroupChatService_UpdateGroupKey_Handler,
		},
		{
			MethodName: "AddGroupMember",
			Handler:    _GroupChatService_AddGroupMember_Handler,
		},
		{
			MethodName: "RemoveGroupMember",
			Handler:    _GroupChatService_RemoveGroupMember_Handler,
		},
		{
			MethodName: "RequestMissingGroupMessages",
			Handler:    _GroupChatService_RequestMissingGroupMessages_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "internal/proto/speech.proto",
}

const (
	ChatHistoryService_TransferChatHistory_FullMethodName = "/auth.ChatHistoryService/TransferChatHistory"
)

// ChatHistoryServiceClient is the client API for ChatHistoryService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// Chat History Service
type ChatHistoryServiceClient interface {
	TransferChatHistory(ctx context.Context, in *TransferChatHistoryRequest, opts ...grpc.CallOption) (*TransferChatHistoryResponse, error)
}

type chatHistoryServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewChatHistoryServiceClient(cc grpc.ClientConnInterface) ChatHistoryServiceClient {
	return &chatHistoryServiceClient{cc}
}

func (c *chatHistoryServiceClient) TransferChatHistory(ctx context.Context, in *TransferChatHistoryRequest, opts ...grpc.CallOption) (*TransferChatHistoryResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(TransferChatHistoryResponse)
	err := c.cc.Invoke(ctx, ChatHistoryService_TransferChatHistory_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ChatHistoryServiceServer is the server API for ChatHistoryService service.
// All implementations must embed UnimplementedChatHistoryServiceServer
// for forward compatibility
//
// Chat History Service
type ChatHistoryServiceServer interface {
	TransferChatHistory(context.Context, *TransferChatHistoryRequest) (*TransferChatHistoryResponse, error)
	mustEmbedUnimplementedChatHistoryServiceServer()
}

// UnimplementedChatHistoryServiceServer must be embedded to have forward compatible implementations.
type UnimplementedChatHistoryServiceServer struct {
}

func (UnimplementedChatHistoryServiceServer) TransferChatHistory(context.Context, *TransferChatHistoryRequest) (*TransferChatHistoryResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TransferChatHistory not implemented")
}
func (UnimplementedChatHistoryServiceServer) mustEmbedUnimplementedChatHistoryServiceServer() {}

// UnsafeChatHistoryServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ChatHistoryServiceServer will
// result in compilation errors.
type UnsafeChatHistoryServiceServer interface {
	mustEmbedUnimplementedChatHistoryServiceServer()
}

func RegisterChatHistoryServiceServer(s grpc.ServiceRegistrar, srv ChatHistoryServiceServer) {
	s.RegisterService(&ChatHistoryService_ServiceDesc, srv)
}

func _ChatHistoryService_TransferChatHistory_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TransferChatHistoryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ChatHistoryServiceServer).TransferChatHistory(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ChatHistoryService_TransferChatHistory_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ChatHistoryServiceServer).TransferChatHistory(ctx, req.(*TransferChatHistoryRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// ChatHistoryService_ServiceDesc is the grpc.ServiceDesc for ChatHistoryService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var ChatHistoryService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "auth.ChatHistoryService",
	HandlerType: (*ChatHistoryServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "TransferChatHistory",
			Handler:    _ChatHistoryService_TransferChatHistory_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "internal/proto/speech.proto",
}
